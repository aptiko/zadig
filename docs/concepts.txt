.. _concepts:

==================
TwistyCMS concepts
==================

Object containment
==================

In TwistyCMS, objects can be contained in other objects. For example,
you can have page ``/mypage/hobbies``, and it can contain
``/mypage/hobbies/django``. There is no separate "folder" object;
instead, any object can act as a container of other objects, in
addition to having its own content. If a page has no content, then it
shows an index of its contained pages (like Plone does for folders
when no page has been set as the folder's default view).

.. admonition:: Philosophy

    Why don't we specifically use folders, as Plone does?  The reason is
    that it conflicts with the URL scheme, where any resource can have
    subresources. Because of this conflict, it is difficult for users to
    understand the notion of a folder and a page. For example, a user
    would normally create a page ``/mypage/hobbies``, and then 
    typically ask: how do I now create ``/mypage/hobbies/django``? The
    Plone reply (hobbies must be made a folder, the current hobbies page
    must become a page inside the folder, and must be set as default, and
    a django [page or folder?] must be created inside the folder) is
    complicated and unintuitive. It also poses a practical problem: the
    user needs to decide a priori whether the page he is about to create
    will contain subpages or whether it is likely to remain a single page.

    On the other hand, other CMS's, like MoinMoin, have pages and
    subpages, and each page can have attachments. This is also
    unintuitive, because, for example, an image does not always belong to
    a "page"; it rather belongs to a folder. ``/myfolder/myimage`` is much
    better and intuitive than ``/mypage?attachment=myimage``.

    Also note that, in Moin, /mypage/mysubpage is a completely different
    and unrelated page to /mypage: it's just a name that contains a slash.
    But in TwistyCMS, /mypage/mysubpage is a page that is contained in
    /mypage, as if the latter were a folder. Moin is even simpler and maps
    even better on the URL scheme, but TwistyCMS makes property
    inheritance (e.g. permissions and skins) much simpler and foolproof:
    any object simply inherits the properties of its container objects.

Entries and vobjects
====================

The end user uses the word *page* (and the more general *object*) with
two meanings, owing to the fact that we do automatic versioning like
that of a wiki. When we say "delete this page", we mean delete an
entire sequence of pages; when we talk about the content of a page, we
mean the content of a specific page version.

When we need to distinguish between the two (and this is when we are
writing code), we use the word **entry** for a sequence of versioned
objects, and the word **vobject** for each specific version of an
entry.  An entry can be a page entry, an image entry, etc., and a
vobject can be a vpage, a vimage, etc.  Developers should be very
clear about that. The end users should not be bothered, and the word
**object** should be used for everything.

Metatags
========

Each object has a **name**, which is what is shown at the URL. Each
object has, in addition, a **long title** and a **short title**.  The
long title shows everywhere except where there is a shortage of space,
namely in the navigation, breadcrumbs, and possibly other applets. The
short title can be omitted, in which case the long title is used. We
use **title pair** to refer to both titles together.

Because of multilinguality, each object can have several title pairs,
one for each language. Although this sounds useless for pages, because
a page is in a given language, and therefore its title pair could also
be in that given language, multilingual title pairs are useful in the
following cases:

* For objects, such as images, that are not bound to a specific
  language.
* For objects that act as folders, and whose short title therefore
  shows in the breadcrumbs when you view a contained object.

As an example, consider the English pages ``/mypage`` and
``/mypage/hobbies``, with titles "My Page" and "Hobbies". Suppose
``/mypage/loisirs`` is the French version of ``/mypage/hobbies``, and
has title "Loisirs". The breadcrumbs for that page would show "My Page
-> Loisirs". However, "Mon Page -> Loisirs" would be better. For this,
we add a French title to ``/mypage``, although the page is English.

If ``/mypage/fr`` is the French version of ``/mypage``, then you don't
want the breadcrumbs to show "Mon Page -> Mon Page"; you want simply
"Mon Page". For this, each object has the option to not show in the
breadcrumbs, and this is generally for pages that are a kind of
"folder defaults" in languages different from the containing objects'
language.

Except for the name and title pairs, an object can also have a
**description**. For pages, the description is a summary of the page,
displayed below the title in bold.  Objects such as images may have
the description in many languages. For uniformity, this applies to all
kinds of object, although for some, such as pages, it is mostly
useless.

The titles and description of each object are collectively named
**metatags**.

In this section we have been talking of "objects". To be precise,
each *entry* has a name, and each *vobject* has a set of metatags
(i.e. a set of title pairs and a set of descriptions).

Deletions
=========

There are two ways to "delete" an object: one is to **mark it as
deleted**. In this case, the entry history is retained, and the
"deletion" is an event recorded in the entry history. Marking an entry
as deleted is creating a new vobject. We consider a vobject as a
deletion mark if it has empty content and empty metatags. Since the
entry exists, another entry with the same name cannot be created.

The second way to delete is to **remove the entry**, in which case the
entry, including the history, is permanently and irrevocably deleted.

.. admonition:: Not implemented yet

   Although the database is ready for all that, deleting an object (in
   any way) has not yet been implemented in the user interface.

Views
=====

Things you can do with an entry or vobject include (but are not
limited to) creating a new entry, viewing a vobject, viewing the entry
history, editing an entry, moving an entry, marking an entry as
deleted, and removing an entry.  The requested operation is specified
by an item in the URL path which has a prefix and a suffix of two
underscores; for example, http://localhost/mypage/__edit__/ is a
request to edit *mypage*. If there is no such item in the URL, then
the request is to view the entry.

There are two ways to view an entry. The **end view** is the normal
mode of viewing an entry; for an image, for example, the end view is a
"image/jpeg" or similar response that contains binary data. The **info
view** is a page that includes information about the image, buttons
for initiating editing, and so on, and is intended mainly for users
who have permissions to modify the image. For some object types, such
as pages, the end view and the info view may be identical.
http://localhost/myobject/ provides the end view for *myobject*,
whereas http://localhost/myobject/__view__/ provides the info view.

We also call the rest of the operations *views*. Specifically, there
are the **edit view**, the **contents view**, and the **history
view**.

Permissions and workflows
=========================

There are **users**, and each user can belong to one or more
**groups**. When someone has not logged on then we say that they are
the **anonymous user**. Each user and group has certain
**permissions** on each object. There are five kinds of permissions:
*view*, *edit*, *admin*, *search*, and *delete*. Someone with *edit*
permission, besides editing the entry, can also mark the entry as
deleted, view the list of all subobjects regardless of whether they
have any permission on them, and add subobjects to the entry; you also
need *edit* permission to view the entry history; with *view*
permission you can only view the current entry version (the last
vobject). Someone with *admin* permissions can modify the object's
permissions and state. Someone with *delete* permission can remove the
entry, recursively including its subentries (irrespective of their
permissions). Someone with *search* permission can see the entry in
listings; e.g. the anonymous user has view permission on a public
draft, but not search permission; you can view it if you know its URL,
but it won't show in indexes or searches.  Each entry has an
**owner**, and the owner has all permissions on the object.

.. admonition:: Note

   Why do you need *edit* permission to view the entry history? This
   can be useful if old versions contain confidential information.
   There are alternative ways of doing it, such as adding a
   *view_history* permission, or allowing individual vobjects to have
   separate *view* permissions. This, however, adds complication.
   TwistyCMS is not primarily a wiki, and the possibility for
   unprivileged users to view the history is not considered essential.
   Therefore, we chose to keep it simple for the moment, and leave it
   for the future to find a way around this problem.

At a given time, each entry is in a **state**. A state is a collection
of permissions. For example, these are common states:

Private
   Logged on users can view.

Public draft
   Anonymous user can view.

Published
   Anonymous user can view and search.

A **workflow** is a collection of states and state-transition rules.
A **state-transition rule** is a many-to-one relationship between
states: it shows which are the possible states that follow a given
state. Each instance has one workflow.

In the default installation, two states are created, private and
published, two state-transition rules (from private to published and
vice-versa), and one workflow named "Simple publication workflow"
containing all those. The private state has the *view* and *search*
permissions on logged on users; the published state has the *view* and
*search* permissions on the anonymous user. There are no other
permissions defined, which means that only the owner can edit, admin
and delete.

Applets and portlets
====================

An **applet** is essentially a Django application that provides a template
tag. The breadcrumbs, for example, is an applet, and it provides the
``breadcrumbs`` tag. When you include ``{% breadcrumbs %}`` in a template,
this is replaced by the breadcrumbs.  TwistyCMS is designed so that very
little functionality is in the core; the rest is in applets. Like all
Django applications, applets are installed by adding them to
``INSTALLED_APPS`` in the ``settings.py`` file. Details on the applet
installation procedure are presented further below.

.. admonition:: Note

    For good code structure, a Django application can contain many
    applets: for example, ``twistycms/applets/standard`` contains all the
    standard applets. Therefore, if we want to be precise, an applet
    is not a Django application, but a custom template tag accompanied
    by related functionality such as configuration options (explained
    below).

A **portlet** is a special kind of applet. The only special thing
about it is that it has a certain kind of look: it has a title and a
body, and the body consists of items (some portlets, like navigation,
have only one item in the body). The template tag of the portlet renders the portlet in a very specific manner::

    <dl class="portlet">
      <dt>Portlet title</dt>
      <dd>First item</dd>
      <dd>Second item</dd>
      ...
      <dd class="lastItem">Last item</dd>
    </dl>

Because portlets conform to that specification, the CSS style sheet
can define a common look for all portlets. That is all that is
special about them. Otherwise, they are identical to applets.

Applets included with TwistyCMS, such as the breadcrumbs and the
navigation, are in ``twistycms/applets/standard``.

.. admonition:: Not implemented yet

   The portlets for pending events, news, and calendar have not been
   implemented yet.

Besides a template tag, an applet can also provide a set of
configuration options per object (entry).

The left and right panes, used as portlet holders in the default
template, are applets themselves.

Installing applets
------------------

To install an applet (more precisely, a Django application containing
one or more applets), do the following:

1. Put the directory containing the application under ``twistycms/applets``.
2. Add the application to ``INSTALLED_APPS`` in the ``settings.py``
   file.
3. If there is any additional CSS, put it in the ``static`` directory,
   and add an ``@import`` statement in the main stylesheet (in the
   default template it is named ``style.css``).
4. In the ``twisty`` directory, run ``./manage.py syncdb``. This will
   create any additional database tables needed by the applet.
