.. _developers_guide:

=======================
Zadig Developer's Guide
=======================

There are two things a Zadig developer is expected to do: (1)
create applets; and (2) create new object types. We explain those in
separate chapters below. It is essential to first read the
:ref:`concepts` document.

Creating applets
================

To create an applet (or a set of related applets in a Django
application), create a directory, say ``myapplet``, inside the
``zadig/applets`` directory. Inside ``myapplet``, create an empty
``__init__.py`` file, an empty ``models.py`` file, and a
``templatetags`` directory. Inside ``templatetags``, create an empty
``__init__.py`` and a ``myapplet.py`` file.  In ``myapplet.py``, add
Django code that implements a template tag (we'll assume
``myapplettag``).

That is all you have to do for a basic applet. You can then use
it in your template like this::

    {% load myapplet %}
    ...
    {% myapplettag %}
    ...

If needed, the template tag can accept arguments.

If you want your applet to store information in the database (usually
this is configuration options), add models in ``models.py``. You'll
probably want to reference ``zadig.core.models.Entry`` if you
have options per entry.

If you want your applet to have configuration options, add functions
to ``myapplet/__init__.py``, according to the following::

    from django import forms

    class EntryOptionsForm(forms.Form):
        MyOption = forms.BooleanField()
        # And so on

    def entry_options(request, form=None):
        if not form:
            # Return a Form object that contains the configuration options.
            form = EntryOptionsForm()
            # Populate form with initial values (usually from the database)
            return form
        else:
            # Process configuration options that have been submitted.
            entryoptions.my_option = form.cleaned_data['MyOption']
            # ...
            entryoptions.save()
        
If the applet is a portlet, you need to do two more things. First,
make sure that the tag output conforms to the portlet specification:

.. code-block:: html

    <dl class="portlet">
      <dt>Portlet title</dt>
      <dd>First item</dd>
      <dd>Second item</dd>
      ...
      <dd class="lastItem">Last item</dd>
    </dl>

Second, in ``myapplet/__init__.py``, add the following::

    portlets = [{ 'name': _(u"My portlet"),
                  'tag': "myportlettag", },
                # Obviously add more items to this list if your
                # application defines more than one portlets.
               ]

When Zadig starts, it looks at the ``__init__.py`` file of each
applet directory. If the file contains ``entry_options``, it registers
it. Then, when the user edits a page, Zadig calls
``entry_options`` with ``form=None``, it gets a form as a response, it
remembers its class, and it displays it to the user. When the user
submits it, Zadig creates a bound form of the remembered class
with the request data and calls ``entry_options`` supplying the
created form as the ``form`` argument.  In fact the entry options form
is not treated as a whole form but as a part of a form that is mixed
with the entry options of all other installed applets, resulting in
one form for all applets together; but this makes no difference for
the applet code.

Zadig also registers the portlets it finds in ``__init__.py``.

Creating new object types
=========================

To create a new object type, you need to subclass
:class:`~zadig.core.models.Entry` and
:class:`~zadig.core.models.VObject`, and create a form. Let's
assume that the type you want to create is to be called a Snail. Name
your :class:`~zadig.core.models.Entry` subclass *SnailEntry*, your
:class:`~zadig.core.models.VObject` subclass *VSnail*, and your
form *EditSnailForm*. The code should be as follows::

    from zadig.core.models import Entry, VObject, user_entry_types


    class VSnail(VObject):
        content = models.TextField(blank=True) # Or whatever it is

        def end_view(self):
            return render_to_response('view_snail.html', { 'vobject': self })

        def info_view(self):
            return self.end_view()

        class Meta:
            db_table = 'myprefix_vsnail'


    class EditSnailForm(forms.Form):
        content = forms.CharField()

        def render(self):
            return self.as_table()


    class SnailEntry(Entry):
        template_name = 'edit_snail.html'
        subform_class = EditSnailForm
        vobject_class = VSnail
        typename = _(u"Snail")

        def create_edit_subform(self, new):
            if new:
                result = EditSnailForm()
            else:
                result = EditSnailForm(
                        initial={'content': self.vobject.content})
            return result

        def process_edit_subform(self, vobject, form):
            vobject.content=form.cleaned_data['content']

        class Meta:
            db_table = 'myprefix_snailentry'


    user_entry_types.append(SnailEntry)

.. admonition:: Incomplete

   More to write here in order to explain the above example.

.. _request-object:

The request object
==================

:class:`~zadig.core.models.Entry` and
:class:`~zadig.core.models.VObject` objects need to be aware of
the *request* object all the time. They use the *request* object
for two purposes: (1) they use ``request.user`` to check whether
the user has permissions to do various operations; (2) they store
information for later usage in the *request* object; for example,
they create an attribute at the *request* object that holds a list
of multilingual groups that will be checked for integrity on
commit.

Usually you create :class:`~zadig.core.models.Entry` objects by
calling the ``get_by_path()`` method of the :attr:`default manager
<zadig.core.models.Entry.objects>`, or by using the default
constructor, in which case you supply the *request* object; the entry
returned will have a *request* attribute with the supplied object.
Likewise, the usual way to get to a
:class:`~zadig.core.models.VObject` object, is via the
:attr:`~zadig.core.models.Entry.vobject` property or the
:meth:`~zadig.core.models.Entry.get_vobject()` method of an
:class:`~zadig.core.models.Entry` object; the returned object will
have the *request* attribute assigned.  If you have a
:class:`~zadig.core.models.VObject` and you need to get to its
entry, use the :attr:`~zadig.core.models.VObject.rentry` property
rather than the :attr:`~zadig.core.models.VObject.entry`
attribute, which will also assign the *request* object to the returned
entry.

If you need to create an entry or vobject in any way other than the
normal ways provided by the API, then manually assign the request
object, as in the following example::

  e = Entry.objects.get(id=my_id)
  e.request = request

If you are not using the API in the context of a web server (for
example if you are creating a command-line utility), and therefore
you don't have a request object, create one and make certain it has
a *user* attribute::

  from django.http import HttpRequest
  from django.contrib.auth.models import User
  request = HttpRequest()
  request.user = User.objects.get(username=MY_USERNAME)
