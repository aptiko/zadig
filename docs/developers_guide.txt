.. _developers_guide:

=======================
Zadig Developer's Guide
=======================

There are two things a Zadig developer is expected to do: (1) create
new object types; and (2) create applets. We explain those in separate
chapters below. It is essential to first read the :ref:`concepts`
document.

Creating Zadig applications
===========================

A Zadig application is a Django application, and, as such, is added in
the :data:`INSTALLED_APPS` setting. The application can reside
anywhere in the Python path. The Zadig applications (e.g.
``zadig.zstandard`` included in the Zadig distribution are under the
:file:`zadig` directory.

Such applications should have an :file:`__init__.py` file and a
:file:`__models__.py`. If they have any extra templates, they should
also have a :file:`templates` directory (for example, the
``zadig.zstandard`` application, which contains the standard objects,
has templates such as :file:`view_page.html` etc.). If they have
applets, they should also have a :file:`templatetags` directory. If
they have any additional general views, these should be in
:file:`views.py` (general views will be examined below).

Creating new object types
=========================

New object types are declared in :file:`models.py`.  You need to
subclass :class:`~zadig.core.models.Entry` and
:class:`~zadig.core.models.VObject`, and create a form for editing the
object.

The :class:`~zadig.core.models.Entry` subclass must define the
:attr:`~zadig.core.models.Entry.vobject_class` class attribute, whose
value must be the :class:`~zadig.core.models.VObject` subclass.  The
:class:`~zadig.core.models.Entry` subclass should also define 
:attr:`~zadig.core.models.Entry.typename`. Finally, when necessary, it
should also override
:attr:`~zadig.core.models.Entry.edit_template_name`,
:meth:`~zadig.core.models.Entry.edit_subform`, and
:meth:`~zadig.core.models.Entry.process_edit_subform`.

The :class:`~zadig.core.models.VObject` subclass should have Django
fields for storing the vobject content, and it should also define the 
:meth:`~zadig.core.models.VObject.end_view` and
:meth:`~zadig.core.models.VObject.info_view` methods.

If you use the existing applications' object types implementation as
an example, you should not have any problem understanding things
better.

General views
=============

When the URL is of the form
:samp:`/{path_to_entry}/__{viewname}__/{remainder}` and *viewname* is
not known to the Zadig core code, then Zadig searches for such a view
in three places:

1. It checks whether the :class:`~zadig.core.models.VObject` pointed
   by *path_to_entry* has a method called :samp:`{viewname}_view`.
2. Failing that, it searches for such a method in the
   :class:`~zadig.core.models.Entry` class.
3. Failing that, if *viewname* contains a dot, i.e. it is of the form
   *app.func*, it searches for a callable *func* in
   :samp:`zadig.{app}.views`.

If no appropriate callable is found, :exc:`Http404` is raised. If it
is found, it is called passing the URL *remainder* as the ``parms``
argument.

An example of such a view is the "resized" view of an image. If you
append ``/__resized__/400`` to the URL of an image, then you will see
the image resized so that its largest dimension is 400 pixels. This is
accomplished because the :class:`zadig.zstandard.VImage` class has a
:meth:`~zadig.zstandard.VImage.resized_view` method. Another example
is page comment submission: the "add comment" submit button results in
posting the "add comment" form to a URL that ends in
``/__zpagecomments.add_comment__/``, which is processed by
:func:`zadig.zpagecomments.views.add_comment`.

Creating applets
================

To create an applet, create a custom template tag (read the Django
documentation for that).  If you want your applet to store information
in the database, add models in :file:`models.py`.

.. admonition:: Incomplete

   I've not yet gotten to write about entry option sets.

If the applet is a portlet, you need to do two more things. First,
make sure that the tag output conforms to the portlet specification:

.. code-block:: html

    <dl class="portlet">
      <dt>Portlet title</dt>
      <dd>First item</dd>
      <dd>Second item</dd>
      ...
      <dd class="lastItem">Last item</dd>
    </dl>

Second, in the top level :file:`__init__.py` of your application, add
the following::

    from zadig.core import portlets
    portlets.append({ 'name': _(u"My portlet"), 'tag': "myportlettag", },
                    # Add more items to this list if your
                    # application defines more than one portlets.
                   )

.. _request-object:

The request object
==================

:class:`~zadig.core.models.Entry` and
:class:`~zadig.core.models.VObject` objects need to be aware of
the *request* object all the time. They use the *request* object
for two purposes: (1) they use ``request.user`` to check whether
the user has permissions to do various operations; (2) they store
information for later usage in the *request* object; for example,
they create an attribute at the *request* object that holds a list
of multilingual groups that will be checked for integrity on
commit.

Usually you create :class:`~zadig.core.models.Entry` objects by
calling the ``get_by_path()`` method of the :attr:`default manager
<zadig.core.models.Entry.objects>`, or by using the default
constructor, in which case you supply the *request* object; the entry
returned will have a *request* attribute with the supplied object.
Likewise, the usual way to get to a
:class:`~zadig.core.models.VObject` object, is via the
:attr:`~zadig.core.models.Entry.vobject` property or the
:meth:`~zadig.core.models.Entry.get_vobject()` method of an
:class:`~zadig.core.models.Entry` object; the returned object will
have the *request* attribute assigned.  If you have a
:class:`~zadig.core.models.VObject` and you need to get to its
entry, use the :attr:`~zadig.core.models.VObject.rentry` property
rather than the :attr:`~zadig.core.models.VObject.entry`
attribute, which will also assign the *request* object to the returned
entry.

If you need to create an entry or vobject in any way other than the
normal ways provided by the API, then manually assign the request
object, as in the following example::

  e = Entry.objects.get(id=my_id)
  e.request = request

If you are not using the API in the context of a web server (for
example if you are creating a command-line utility), and therefore
you don't have a request object, create one and make certain it has
a *user* attribute::

  from django.http import HttpRequest
  from django.contrib.auth.models import User
  request = HttpRequest()
  request.user = User.objects.get(username=MY_USERNAME)
