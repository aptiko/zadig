#!/usr/bin/python
"""
This script is in heavy development. Don't expect it to work.

Usage: plone2twistycms auth

auth is the value the __ac cookie should have.

"""

PLONE_URL='https://itia.ntua.gr/antonis/'
                        # Will migrate this and all subobjects of it.
TARGET_PATH='antonis'   # Will migrate PLONE_URL to this path, and subobjects
                        # to subpaths. If TARGET_PATH already exists, it and
                        # its subentries are deleted.
OWNER='admin'           # The objects created will belong to this user.
DEFAULT_LANGUAGE='en'   # When a Plone page is "language neutral", it will be
                        # considered to be in this language.

import sys
import urllib2
from cookielib import CookieJar
import logging

from BeautifulSoup import BeautifulSoup, Tag

from django.conf import settings
from django.db import transaction

from twistycms.core.utils import sanitize_html
from twistycms.core.utils import split_path
from twistycms.core import models

class UnknownPloneObjectType(Exception): pass

def get_response(url):
    """Get the data from the url, which should be Plone. Send the logon cookie
    during the request, to make sure we are logged on to Plone."""
    request = urllib2.Request(url)
    request.add_header('Cookie', '__ac=%s' % (sys.argv[1],))
    return urllib2.urlopen(request)

class PloneObject(object):
    def __new__(cls, url, soup=None):
        """Don't return a PloneObject; return a subclass object, depending on
        what we find at the url."""
        if cls != PloneObject:
            # It's a subclass being created
            return super(PloneObject, cls).__new__(cls)
        logging.info("Working on %s" % (url,))
        assert(soup is None)
        soup = BeautifulSoup(get_response(url).read())
        t = soup.find('li', id='contentview-folderContents')
        if t:
            # It has a contents tab, therefore it could be a folder
            folder_contents_link = t.a['href']
            if not url.endswith('/'): url += '/'
            if folder_contents_link == url + 'folder_contents':
                # Yes, it's a folder
                logging.debug("(It's a folder)")
                return super(PloneObject, cls).__new__(PloneFolder)
            # Otherwise, we assume it is the default folder view
            logging.debug("(It's a default folder view)")
            return super(PloneObject, cls).__new__(PloneDefaultFolderView)
        body_classes = soup.find('body')['class'].split()
        if 'template-document_view' in body_classes:
            logging.debug("(It's a page)")
            return super(PloneObject, cls).__new__(PlonePage)
        if 'template-image_view' in body_classes:
            logging.debug("(It's an image)")
            return super(PloneObject, cls).__new__(PloneImage)
        if 'template-link_view' in body_classes:
            logging.debug("(It's a link)")
            return super(PloneObject, cls).__new__(PloneLink)
        raise UnknownPloneObjectType("Unknown object type at "+url)
    def __init__(self, url, soup=None):
        """Retrieve title, description and state from a Plone page;
        for subclasses, also retrieve content. soup is the BeautifulSoup object
        resulting from parsing the url."""
        self.url = url
        if not soup:
            html = get_response(url).read()
            soup = BeautifulSoup(html)
        self.soup = soup
        self.title = self.soup.find(True,
                            id='parent-fieldname-title').string.strip()
        d = self.soup.find(True, id='parent-fieldname-description')
        # Sometimes (pages) d is a span containing text, sometimes (folders
        # without default view) it's a div containing p.
        if d.string: self.description = d.string.strip()
        else: self.description = d.p.string.strip()
        self.state = self.soup.find('dl', id='plone-contentmenu-workflow'
            ).dt('span')[1].string.strip()
                            
    def determine_language(self):
        """Find language of object by going to its edit view and checking
        the language setting. Return a models.Language object or None if the
        object is a language neutral object."""
        # FIXME
        return models.Language.objects.get(id=DEFAULT_LANGUAGE)

class PlonePage(PloneObject):
    def __init__(self, url, soup=None):
        PloneObject.__init__(self, url, soup=soup)
        text = self.soup.find('div', id='parent-fieldname-text')
        self.content = text
    def fix_content(self, request, path):
        """Make several appropriate changes to the HTML read from Plone. On
        entry self.content is practically a soup; on exit it's a string."""

        # Empty if empty
        if not self.content:
            self.content = u''
            return

        # Take headings one level up
        for h2 in self.content.findAll('h2'):
            h1 = Tag(self.soup, "h1")
            h1.insert(0, h2.renderContents())
            h2.replaceWith(h1)
        for h3 in self.content.findAll('h3'):
            h2 = Tag(self.soup, "h2")
            h2.insert(0, h3.renderContents())
            h3.replaceWith(h2)

        # Fix internal references to images
        for img in self.content.findAll('img'):
            src = img['src']
            if src.endswith('/image_preview'): src = src[:-13]
            if not src.startswith('/'):
                src = '/'.join(split_path(path)[:-1]) + '/' + src
            img['src'] = src
        
        self.content = u''.join([unicode(x) for x in self.content.contents])

    @transaction.commit_on_success
    def migrate(self, request, path):
        self.fix_content(request, path)
        language = self.determine_language()
        entry = models.PageEntry(request, path)
        entry.state = models.State.objects.get(descr=self.state)
        entry.save()
        nvobject = models.VPage(entry=entry, version_number=1, language=language,
            format = models.ContentFormat.objects.get(descr='html'),
            content = sanitize_html(self.content))
        nvobject.save()
        nmetatags = models.VObjectMetatags(vobject=nvobject, language=language,
            title=self.title, description=self.description)
        nmetatags.save()

class PloneImage(PloneObject):
    def __init__(self, url, soup=None):
        PloneObject.__init__(self, url, soup=soup)
        assert(url.endswith('/view'))
        url = url[:-5]
        response = get_response(url)
        self.mimetype = response.info().type
        self.content =  response.read()
    @transaction.commit_on_success
    def migrate(self, request, path):
        from django.core.files.base import ContentFile
        from mimetypes import guess_extension
        language = self.determine_language()
        entry = models.ImageEntry(request, path)
        entry.state = models.State.objects.get(descr=self.state)
        entry.save()
        f = ContentFile(self.content)
        extension = guess_extension(self.mimetype)
        nvobject = models.VImage(entry=entry, version_number=1)
        nvobject.content.save('%s-0001%s'%(entry.name, extension), f)
        nvobject.save()
        f.close()
        nmetatags = models.VObjectMetatags(vobject=nvobject, language=language,
            title=self.title, description=self.description)
        nmetatags.save()

class PloneLink(PloneObject):
    def __init__(self, url, soup=None):
        PloneObject.__init__(self, url, soup=soup)
        self.target = self.soup.find('p', attrs={'class':'documentDescription'}
                                ).findNextSibling('p').a['href']
    @transaction.commit_on_success
    def migrate(self, request, path):
        language = self.determine_language()
        entry = models.LinkEntry(request, path)
        entry.state = models.State.objects.get(descr=self.state)
        entry.save()
        nvobject = models.VLink(entry=entry, version_number=1, language=language,
            target = self.target)
        nvobject.save()
        nmetatags = models.VObjectMetatags(vobject=nvobject, language=language,
            title=self.title, description=self.description)
        nmetatags.save()

class PloneDefaultFolderView(PloneObject):
    @transaction.commit_on_success
    def migrate(self, request, path):
        entry = models.InternalRedirectionEntry(request, path)
        entry.state = models.State.objects.get(descr=self.state)
        entry.save()
        nvobject = models.VInternalRedirection(entry=entry, version_number=1,
            target=entry.container)
        nvobject.save()
        nmetatags = models.VObjectMetatags(vobject=nvobject,
            language=self.determine_language(), title=self.title,
            description=self.description)
        nmetatags.save()

class PloneFolder(PlonePage):
    def __init__(self, url, soup=None):
        PlonePage.__init__(self, url, soup=soup)
        # Does it have a default view?
        if not self.soup.find('a', id='_folderChangeDefaultPage'):
            self.content = ''
    @transaction.commit_on_success
    def migrate(self, request, path):
        # TwistyCMS does not have folders, so we'll become a page. First
        # of all migrate the page.
        PlonePage.migrate(self, request, path)
        # But also migrate the contents of the folder
        url = self.url
        if not url.endswith('/'): url += '/'
        url += 'folder_contents'
        soup = BeautifulSoup(get_response(url).read())
        tr_elements = soup.find('table', id='listing-table').tbody('tr')
        for tr in tr_elements:
            url = tr.a['href']
            if url.endswith('/folder_contents'): url = url[:-16]
            plone_object = PloneObject(url)
            if url.endswith('/view'): url = url[:-5] # Probably an image 
            npath = path + '/' + url.split('/')[-1]
            plone_object.migrate(request, npath)

logging.basicConfig(level=logging.DEBUG)

# We use HttpRequest as a small hack. Some Entry methods require request to be
# passed to them, but they hardly use anything but request.user. So we set
# that and we're OK.
from django.http import HttpRequest
from django.contrib.auth.models import User
request = HttpRequest()
request.user = User.objects.get(username=OWNER)

plone_object = PloneObject(PLONE_URL)
path = TARGET_PATH
entry = models.Entry.objects.get_by_path(request, path)
if entry:
    entry.delete()
plone_object.migrate(request, path)
