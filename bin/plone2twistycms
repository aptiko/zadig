#!/usr/bin/python
"""
This script is in heavy development. Don't expect it to work.

Usage: plone2twistycms auth [lang]

auth is the value the __ac cookie should have. If lang is present,
it is the value of the I18N_LANGUAGE cookie, which defines the
LinguaPlone language requested.

"""

PLONE_URL='https://itia.ntua.gr/antonis/'
                        # Will migrate this and all subobjects of it.
TARGET_PATH='antonis'   # Will migrate PLONE_URL to this path, and subobjects
                        # to subpaths. If TARGET_PATH already exists, it and
                        # its subentries are deleted.
OWNER='admin'           # The objects created will belong to this user.
DEFAULT_LANGUAGE='en'   # When a Plone page is "language neutral", it will be
                        # considered to be in this language.

import sys
import urllib2
import logging

from BeautifulSoup import BeautifulSoup, Tag

from django.conf import settings
from django.db import transaction

from twistycms.core.utils import sanitize_html
from twistycms.core.utils import split_path
from twistycms.core import models

class UnknownPloneObjectType(Exception): pass

def get_response(url):
    """Get the data from the url, which should be Plone. Send the logon cookie
    during the request, to make sure we are logged on to Plone."""
    request = urllib2.Request(url)
    cookies = '__ac="%s"' % (auth_cookie,)
    if auth_lang: cookies += '; I18N_LANGUAGE="%s"' % (auth_lang,)
    request.add_header('Cookie', cookies)
    return urllib2.urlopen(request)

class PloneObject(object):
    def __new__(cls, url, soup=None):
        """Don't return a PloneObject; return a subclass object, depending on
        what we find at the url."""
        if cls != PloneObject:
            # It's a subclass being created
            return super(PloneObject, cls).__new__(cls)
        logging.info("Working on %s" % (url,))
        assert(soup is None)
        soup = BeautifulSoup(get_response(url).read())
        t = soup.find('li', id='contentview-folderContents')
        if t:
            # It has a contents tab, therefore it could be a folder
            folder_contents_link = t.a['href']
            if not url.endswith('/'): url += '/'
            if folder_contents_link == url + 'folder_contents':
                # Yes, it's a folder
                logging.debug("(It's a folder)")
                return super(PloneObject, cls).__new__(PloneFolder)
            # Otherwise, we assume it is the default folder view
            logging.debug("(It's a default folder view)")
            return super(PloneObject, cls).__new__(PloneDefaultFolderView)
        body_classes = soup.find('body')['class'].split()
        if 'template-document_view' in body_classes:
            logging.debug("(It's a page)")
            return super(PloneObject, cls).__new__(PlonePage)
        if 'template-image_view' in body_classes:
            logging.debug("(It's an image)")
            return super(PloneObject, cls).__new__(PloneImage)
        if 'template-link_view' in body_classes:
            logging.debug("(It's a link)")
            return super(PloneObject, cls).__new__(PloneLink)
        raise UnknownPloneObjectType("Unknown object type at "+url)
    def __init__(self, url, soup=None, editsoup=None):
        """Retrieve title, description and state from a Plone page;
        for subclasses, also retrieve content. soup is the BeautifulSoup object
        resulting from parsing the url. editsoup is the soup resulting from
        clicking the Plone "Edit" tab."""
        self.url = url
        if not soup:
            html = get_response(url).read()
            soup = BeautifulSoup(html)
        if not editsoup:
            editurl = soup.find('li', attrs={'id': 'contentview-edit'}).a['href']
            html = get_response(editurl).read()
            editsoup = BeautifulSoup(html)
        self.soup = soup
        self.editsoup = editsoup
        self.title = self.soup.find(True,
                            id='parent-fieldname-title').string.strip()
        self.description = self.editsoup.find('textarea', id='description'
                                                            ).string
        if not self.description: self.description = ""
        self.state = self.soup.find('dl', id='plone-contentmenu-workflow'
            ).dt('span')[1].string.strip()
                            
    def determine_settings(self):
        """Find language and other settings of object by going checking the
        contents of its edit view."""
        a = self.editsoup.find('input', attrs={'id': 'excludeFromNav'})
        self.no_nav = 'checked' in [x[0] for x in a.attrs]
        l = self.editsoup.find('select', attrs={'id': 'language'}).find(
                            'option', attrs={'selected': 'selected'})
        self.language = models.Language.objects.get(id=l['value'] if l
                                                    else DEFAULT_LANGUAGE)

class PlonePage(PloneObject):
    def __init__(self, url, soup=None, editsoup=None):
        PloneObject.__init__(self, url, soup=soup, editsoup=editsoup)
        # Plone sometimes contains an identical div inside the div, therefore
        # rather than searching for an assumed single div with a given id,
        # we pick the innermost.
        text = self.soup.findAll('div', id='parent-fieldname-text')[-1]
        self.content = text
    def fix_content(self, request, path):
        """Make several appropriate changes to the HTML read from Plone. On
        entry self.content is practically a soup; on exit it's a string."""

        # Empty if empty
        if not self.content:
            self.content = u''
            return

        # Take headings one level up
        for h2 in self.content.findAll('h2'):
            h1 = Tag(self.soup, "h1")
            h1.insert(0, h2.renderContents())
            h2.replaceWith(h1)
        for h3 in self.content.findAll('h3'):
            h2 = Tag(self.soup, "h2")
            h2.insert(0, h3.renderContents())
            h3.replaceWith(h2)

        # Fix internal references to images
        for img in self.content.findAll('img'):
            src = img['src']
            if src.endswith('/image_preview'): src = src[:-13]
            if not src.startswith('/'):
                src = '/'.join(split_path(path)[:-1]) + '/' + src
            img['src'] = src
        
        self.content = u''.join([unicode(x) for x in self.content.contents])

    @transaction.commit_on_success
    def migrate(self, request, path):
        self.fix_content(request, path)
        self.determine_settings()
        entry = models.PageEntry(request, path)
        entry.state = models.State.objects.get(descr=self.state)
        entry.save()
        nvobject = models.VPage(entry=entry, version_number=1,
            language=self.language,
            format = models.ContentFormat.objects.get(descr='html'),
            content = sanitize_html(self.content))
        nvobject.save()
        nmetatags = models.VObjectMetatags(vobject=nvobject,
            language=self.language, title=self.title,
            description=self.description)
        nmetatags.save()
        # FIXME: Should be in superclass, other types also have no_nav
        from twistycms.applets.standard.models import EntryOptions
        options = EntryOptions(entry=entry, no_navigation=self.no_nav)
        options.save()

class PloneImage(PloneObject):
    def __init__(self, url, soup=None, editsoup=None):
        PloneObject.__init__(self, url, soup=soup, editsoup=editsoup)
        assert(url.endswith('/view'))
        url = url[:-5]
        response = get_response(url)
        self.mimetype = response.info().type
        self.content =  response.read()
    @transaction.commit_on_success
    def migrate(self, request, path):
        from django.core.files.base import ContentFile
        from mimetypes import guess_extension
        self.determine_settings()
        entry = models.ImageEntry(request, path)
        entry.state = models.State.objects.get(descr=self.state)
        entry.save()
        f = ContentFile(self.content)
        extension = guess_extension(self.mimetype)
        nvobject = models.VImage(entry=entry, version_number=1)
        nvobject.content.save('%s-0001%s'%(entry.name, extension), f)
        nvobject.save()
        f.close()
        nmetatags = models.VObjectMetatags(vobject=nvobject,
            language=self.language, title=self.title,
            description=self.description)
        nmetatags.save()

class PloneLink(PloneObject):
    def __init__(self, url, soup=None, editsoup=None):
        PloneObject.__init__(self, url, soup=soup, editsoup=editsoup)
        self.target = self.soup.find('p', attrs={'class':'documentDescription'}
                                ).findNextSibling('p').a['href']
    @transaction.commit_on_success
    def migrate(self, request, path):
        self.determine_settings()
        entry = models.LinkEntry(request, path)
        entry.state = models.State.objects.get(descr=self.state)
        entry.save()
        nvobject = models.VLink(entry=entry, version_number=1,
            language=self.language, target = self.target)
        nvobject.save()
        nmetatags = models.VObjectMetatags(vobject=nvobject,
            language=self.language, title=self.title,
            description=self.description)
        nmetatags.save()

class PloneDefaultFolderView(PloneObject):
    @transaction.commit_on_success
    def migrate(self, request, path):
        self.determine_settings()
        entry = models.InternalRedirectionEntry(request, path)
        entry.state = models.State.objects.get(descr=self.state)
        entry.save()
        nvobject = models.VInternalRedirection(entry=entry, version_number=1,
            target=entry.container)
        nvobject.save()
        nmetatags = models.VObjectMetatags(vobject=nvobject,
            language=self.language, title=self.title,
            description=self.description)
        nmetatags.save()

class PloneFolder(PlonePage):
    def __init__(self, url, soup=None, editsoup=None):
        PlonePage.__init__(self, url, soup=soup, editsoup=editsoup)
        # Does it have a default view?
        if not self.soup.find('a', id='_folderChangeDefaultPage'):
            self.content = ''
    @transaction.commit_on_success
    def migrate(self, request, path):
        # TwistyCMS does not have folders, so we'll become a page. First
        # of all migrate the page.
        PlonePage.migrate(self, request, path)
        # But also migrate the contents of the folder
        url = self.url
        if not url.endswith('/'): url += '/'
        url += 'folder_contents'
        soup = BeautifulSoup(get_response(url).read())
        tr_elements = soup.find('table', id='listing-table').tbody('tr')
        for tr in tr_elements:
            url = tr.a['href']
            if url.endswith('/folder_contents'): url = url[:-16]
            plone_object = PloneObject(url)
            if url.endswith('/view'): url = url[:-5] # Probably an image 
            npath = path + '/' + url.split('/')[-1]
            plone_object.migrate(request, npath)

logging.basicConfig(level=logging.DEBUG)

auth_cookie = sys.argv[1]
auth_lang = sys.argv[2] if len(sys.argv)>2 else None

# We use HttpRequest as a small hack. Some Entry methods require request to be
# passed to them, but they hardly use anything but request.user. So we set
# that and we're OK.
from django.http import HttpRequest
from django.contrib.auth.models import User
request = HttpRequest()
request.user = User.objects.get(username=OWNER)

plone_object = PloneObject(PLONE_URL)
path = TARGET_PATH
entry = models.Entry.objects.get_by_path(request, path)
if entry:
    entry.delete()
plone_object.migrate(request, path)
